// Conditional Media Query
//
// http://codepen.io/dsheiko/pen/KeLGy
//
@function translate-media-condition( $condition ) {
  $map: (
    "screen": "only screen",
    "xs": " ",
    "sm": " and (min-width: #{$grid-sm-min})",
    "md": " and (min-width: #{$grid-md-min})",
    "lg": " and (min-width: #{$grid-lg-min})"
  );

  @return map-get( $map, $condition );
}

@mixin media($args...) {
  $query: "";

  @each $arg in $args {
    $query: $query + translate-media-condition($arg);
  }

  @media #{ $query }  { @content; }
}

// Generate Flex Alignments
//
@mixin flex-alignments( $parent, $axis, $class, $requester ) {

  @each $element in $class {

    $selector: nth($element, 1);
    $rule: unquote(nth($element, 2));

    #{ $parent }#{ $selector } {

      @if $axis == "x" {

        justify-content: $rule;
        text-align: $rule;

      } @else if $axis == "y" {

        @if $requester == "parent" {

          align-items: $rule;

        } @else {

          align-self: $rule;
        }
      }
    }
  }
}

//////////////////////////////////////
//
// Author: Vladut Radulescu @ Studio51
// MIT LICENSE Â© 2015 Studio51

// Enable Bootstrap OR Foundation as your additional framework in order to
// provide a fallback for older browsers that don't support flexbox.
// Please note that this will change the way you write your grid, so please read
// the documentation before enabling any of these
//
// Options: [true / false]
//
// $grid-bootstrap: false;
// $grid-foundation: false;
//
// Milestone v2.0

// Grid gutters
//
// (!) *giggle* Your gutter will be automatically halfed once compiled.
// $grid-gutter: 10px will compile a gutter of 5px
//
$grid-gutter: 0 !default;

// In order to minimze the compiled CSS, we've left out some rules that are
// default.
// If you experience any issues with the grid please let us know by opening an
// issue on Github and enable the following variable.
//
// Options: [true / false]
//
$grid-minimal: true !default;

// The number of columns the grid will have
// GridleCSS supports up to 24 columns. Beyond that, it's up to you to make it
// work
//
// Options: [12 / 24]
//
$grid-columns: 12 !default;

// Grid breakpoints
//
// Options: [xs sm md lg]
//
$grid-breakpoints: "xs" "sm" "md" "lg";

// Grid breakpoints
// If you want to add more, just make sure you respect the naming convention:
//
// $grid-#{key}-min: #{value};
//
// $grid-sm-min: 40.063em;
// $grid-md-min: 64.063em;
// $grid-lg-min: 90.063em;
//
$grid-sm-min: 768px;
$grid-md-min: 982px;
$grid-lg-min: 1200px;

// Distribute the cells spacing around or between them
//
$flex-distribution: true !default;
$flex-distributions: "around" "between";

// Alignments for main axis  (x): left, center, right
// Alignments for cross axis (y): top, middle, bottom, baseline
//
$flex-alignment: true !default;
$flex-alignments: "x" ("center"("center"), "right"("flex-end")),
                  "y" ("top"("flex-start"), "middle"("center"), "bottom"("flex-end"), "baseline"("baseline"), "stretch"("stretch"));


:root {
  --grid-xs-container: calc( #{ $grid-sm-min });
  --grid-sm-container: calc( #{ $grid-sm-min + $grid-gutter });
  --grid-md-container: calc( #{ $grid-md-min + $grid-gutter });
  --grid-lg-container: calc( #{ $grid-lg-min + $grid-gutter });
  --grid-gutter: $grid-gutter;
  --grid-gutter-calc: calc( var(--grid-gutter) / 2);
}

@import "gridlecss/mixins";

*,
*:before,
*:after {
  box-sizing: border-box;
}

.grid {
  width: 1200px;
}

.grid,
.grid--fluid {
  margin-left: auto;
  margin-right: auto;
  width: 100%;
  height: 100%;
}

  .row,
  .column {
    display: flex;
  }

  .row {
    flex: 0 1 auto;
    flex-direction: row;
    flex-wrap: wrap;
    margin-left: -( var(--grid-gutter-calc));
    margin-right: -( var(--grid-gutter-calc));

    &--reverse {
      flex-direction: row-reverse;
    }
  }

  .column {
    flex-direction: column;

    &--reverse {
      flex-direction: column-reverse;
    }
  }

    @if $flex-distribution {
      @each $distribution in $flex-distributions {

        .distribute-#{ $distribution } {
          justify-content: space-#{ $distribution };
        }
      }
    }

    @if $flex-alignment {
      @each $alignment in $flex-alignments {
        @include flex-alignments( ".align-", nth($alignment, 1), nth($alignment, 2), "parent");
      }
    }

    .cell {
      margin-left: var(--grid-gutter-calc);
      margin-right: var(--grid-gutter-calc);
      flex-basis: 100%;
      max-width: 100%;

      &-order {
        &--first {
          order: -1;
        }

        &--last {
          order: 1;
        }
      }

      @if $flex-alignment {

        &-align {

          @each $alignment in $flex-alignments {
            @include flex-alignments( "&--", "y", nth($alignment, 2), "child");
          }
        }
      }
    }

    %cell-styles {
      display: flex;
      flex: 1 0 auto;
      flex-direction: column;
    }

@each $breakpoint in $grid-breakpoints {

  @include media("screen", $breakpoint) {

    .grid {
      width: var(--grid-#{ $breakpoint }-container);
    }

    // Compiles: distribute-* for each viewport
    //
    .distribute-#{ $breakpoint } {

      @if $flex-distribution {
        @each $distribution-option in $flex-distributions {

          &-#{ $distribution-option } {
            justify-content: space-#{ $distribution-option };
          }
        }
      }
    }

    // Compiles: align-* for each viewport
    //
    .align-#{ $breakpoint } {

      @if $flex-alignment {
        @each $align-option in $flex-alignments {
          @include flex-alignments( "&-", nth($align-option, 1), nth($align-option, 2), "parent");
        }
      }
    }

    // Compiles: cell-*, cell-*-# and cell-*-offset-# for each viewport
    //
    @for $i from 1 through $grid-columns {

      .cell-#{ $breakpoint },
      .cell-#{ $breakpoint }-#{ $i },
      .cell-#{ $breakpoint }-offset-#{ $i } {
        @extend %cell-styles;
      }
    }

    // Compiles: cell-* for each viewport
    //
    .cell-#{ $breakpoint } {
      flex: 1 0;
      flex-basis: 0;
      max-width: 100%;

      &-order {
        &--first {
          order: -1;
        }

        &--last {
          order: 1;
        }
      }

      &-offset {
        margin-left: $grid-gutter !important;
      }

      @if $flex-alignment {

        &-align {

          @each $alignment in $flex-alignments {
            @include flex-alignments( "&--", "y", nth($alignment, 2), "child");
          }
        }
      }
    }

    @for $i from 1 through $grid-columns {
      $grid-column-width: (( 100 / $grid-columns ) * $i ) * 1%;
      $grid-gutter-calc: $grid-gutter / ( $grid-gutter * 0 + 1 );

      // Compiles: cell-*-# for each viewport
      //
      .cell-#{ $breakpoint }-#{ $i } {
        flex-basis: $grid-column-width - $grid-gutter-calc;
        max-width: $grid-column-width;
      }

      // Compiles: cell-*-offset-# for each viewport
      //
      .cell-#{ $breakpoint }-offset-#{ $i } {
        margin-left: $grid-column-width !important;
      }
    }
  }
}
